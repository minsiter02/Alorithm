# 2193 이친수
1.이친수는 0으로 시작하지 않는다.
2.이친수에서는 1이 두 번 연속으로 나타나지 않는다. 즉, 11을 부분 문자열로 갖지 않는다.

예를 들면 1, 10, 100, 101, 1000, 1001 등이 이친수가 된다. 하지만 0010101이나 101101은 각각 1, 2번 규칙에 위배되므로 이친수가 아니다.

N(1 ≤ N ≤ 90)이 주어졌을 때, N자리 이친수의 개수를 구하는 프로그램을 작성하시오.

이친수를 자릿수 별로 계속 작성해보자.


+ N = 1 일 때 (1가지)
    + 1

+ N = 2 일 때 (1가지)
    + 10

+ N = 3 일 때 (2가지)
    + 100
    + 101

+ N = 4 일 때 (3가지)
    + 1000
    + 1001
    + 1010
+ N = 5 일 때 (5가지)
    + 10000
    + 10001
    + 10010
    + 10100
    + 10101
+ N = 6 일 때 (8가지)
    + 100000
    + 100001
    + 100010
    + 100100
    + 100101
    + 101000
    + 101001
    + 101010

...

N 자리 수 에 따른 이친수의 경우의 수가 피보나치 수열의 형태를 띔을 알 수 있다.

최소 제출 코드

```C
#include<stdio.h>

int a(int n){
    if(n == 0)
        return 0; 
    else if(n == 1)
        return 1;
    else 
        return a(n-2) + a(n-1);
}

int main() {
    int n;
    scanf("%d",&n);
    printf("%d\n", a(n));
    return 0;
} 
```

위와 같은 재귀함수를 이용하여 문제를 푸니 2가지 문제가 발생하여 해결했다.

1. 특정 값을 넘어가면 음의 정수가 출력되는 오버플로우.(정수 자료형을 long long int 로 바꾸어 해결함.)
2. 백준 문제 제출시 시간 초과.(시간이 오래 걸리는 재귀함수가 아닌 배열과 반복문을 이용해 해결함.)

main 함수를 분석해보자.

```C
int main(){
    // 자릿수를 저장할 변수 선언.
    int a;
    // 결과 값을 저장할 변수 선언.
    long long int b;
   // 90자리 이친수의 경우의 수를 구하기 위해 배열의 크기를 90으로 선언.
    long long int number[90];

    // 자릿수 입력.
    scanf("%d",&a);

    // 반복문을 이용해 피보나치 수열을 구현.
    for(int i = 1; i <= a ; i++){ 
        if (i == 0){
            number[i] = 0;
            //printf("%lld\n", number[i]);
        }else if (i == 1 || i == 2){
            number[i] = 1;
            //printf("%lld\n", number[i]);
        }else{    
            number[i] = number[i-1] + number[i-2];
            //printf("%lld\n", number[i]);
        }
        // 반복문을 나올 때 마다 i번째 수를 저장.
        b = number[i]; 
    }
    printf("%lld\n", b); // 결과 값 출력.
}
```